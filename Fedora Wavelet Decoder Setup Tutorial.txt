### Wavelet Decoder Setup for Fedora/RPM-based distributions ###
#
#
# <<< If it has a hash in front of it, it's a description and not a command, so don't type it in.
#
#
# Start with a Fedora Server or Fedora Minimal installer.   This boots only to a command prompt with a minimal number of installed packages.
# A server is lighter, and we won't have to deal with trying to remove a display manager which is a lot messier than you'd think, and it has better system management packages selected # by default.
#
# You can download Fedora Server from https://getfedora.org/en/server/
# Image it onto a USB stick using the Fedora Imager (also downloadable), RPI imager, or Rufus.
# Boot into the server and you can use the graphical installed called Anaconda to set everything up.  Default values should be fine.
#
# Choose a sensible root password and make sure to write it down (and that its on a post-it with the machine!! lose the root pw and I'll have to re-do it from scratch if
# anything needs changing.  Don't worry about selecting online repos, creating additional users or anything like that.  We will handle all customization steps later on in this 
# tutorial.
#
# We're making some assumptions here:
#
#	Machine is already imaged with an Ubuntu or Debian os
#	Machine is connected to a wavelet network (via ethernet) and to an internet network (via wifi)
#	Machine hostname is properly set for the target room.
#	Naming convention is:  dec$.type (vim1s, vim3, edge2, opt7090) .dept (part3, mis). room (357m). loc (60C) . wavelet.local
#	The Wavelet server depends on an accurate hostname in order to enumerate the new decoder... or it will eventually when I've written that part.
#
# All of these commands should be run as the root user.  We will worry about setting up the secured user side of things at the end.
#
# Written by Andrew R Melville, in mostly his free time.  Snark mode enabled. 
#
#
# First off, boot and sign in as root, with the root password you just set. 
#
#
# set the machine hostname correctly if that wasn't already done in the installer
# $ indicates a number, try to not pick something that's already being used!
# I know it's long and largely unnecessary but I'd rather get in the habit of being organized early on, so I can screw up later and still feel good about it all.
# Hostnames are important because eventually I want to write automation in the controller to use DNS/DHCP to find what devices to work on.  This would make the system dynamic
# and I won't have to add/remove IP addresses from a text file by hand anymore.   I don't know how to do this yet.  Soon.
hostname dec$.lat$$$$.mis.357m.60c.wavelet.local

# Connect to Public Access wifi...if this doesn't work, we probably have unsupported wifi cards and my advice would be try bringing it up on a different machine.
nmcli dev wifi list
nmcli dev wifi connect Public_Access

# Add flatpak repo
flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

# Add RPMFusion repo for nonfree/copyright restricted applications
dnf install https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm
dnf install https://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

# Now that our repositories are setup and we have internet access enabled, we should update the system immediately to ensure we're on current versions.  This isn't strictly necessary # and because Fedora runs on bleeding-edge kernels, it may even break things.
dnf update

# install necessary dependencies
sudo dnf install nasm ffmpeg vlc rav1e svt-av1 gstreamer1-rtsp-server-devel neofetch minicom gpac podman powerline powerline-fonts vim vim-powerline intel-media-driver intel-gmmlib intel-mediasdk libva libva-intel-driver libva-intel-hybrid-driver gstreamer1-plugins-* intel-gpu-tools mesa-dri-drivers mpv libva-utils libsrtp libsrtp-devel libsrtp-tools srt-devel srt-libs srt cockpit sway swaybg waybar tuned git

# what do these do?	ffmpeg,vlc, rav1e, svt-av1, mpv, gstreamer* gpac are all ffmpeg/gstreamer/codec playback applications and infrastructure.
# 			vim, powerline, minicom, podman, vim-powerline, powerline-fonts, neofetch, cockpit are command line prompts, editors and system tools for general quality-of-#life improvements
#			libsrtp, srt* are libraries for Secure Reliable Transport, a network transport protocol that I intend to leverage (eventually)
#			libva, intel-* mesa-dri-drivers are GPU and video acceleration drivers.   The decoder/encoders that are PC-based use an intel library called VA-API for #acceleration.   Other hardware platforms will have different requirements, and VA-API won't work on non-intel hardware (there's grudging support for the video encoder harwdare in AMD #cards, but basically if its not an Intel CPU / Xe graphics, don't try to use it there)
# sway, swaybg, waybar are components of an extremely lightweight tiling window manager called Sway.   The SBC's have trouble running a full Window Manager like GNOME or KDE, and LXDE # is too complex for our needs.  The decoder just needs to provide a display for video output and nothing else.  Ideally eventually i'd be building my own customized image where the
# UltraGrid executable outputs direct to a display.  It's basically what the MageWell NDI decoder boxes do.   This means the image I'm using is much heavier (1gb or so vs. a 15mb 
# microkernel, web server and decoder based off what I reverse-engineered from the NDI firmwares.
# Tuned is a dynamic system performance tuning daemon.  I'm still playing with it and it might break more than it fixes.
# Git because we are doing things in a somewhat brutal manner and downloading and compiling UltraGrid from source rather than using a prebuilt binary. 

dnf groupupdate multimedia --setop="install_weak_deps=False" --exclude=PackageKit-gstreamer-plugin
dnf groupinstall "C Development Tools and Libraries"

# Install build dependencies for UltraGrid, maximum functionality. 
# As an aside, you can put the flag "dnf install -y" if you don't want to see the prompt.  I prefer it to be interactive just encase I made a mistake, because it sure beats booting into recovery mode # to try and rescue a messed up kernel..

dnf install alsa-lib-devel mesa-libOpenCL-devel pipewire-jack-audio-connection-kit mesa-libGL-devel freeglut-devel glfw-devel ffmpeg-devel openssl-devel portaudio-devel opencv-devel libcurl-devel SDL2 soxr-devel speexdsp-devel vulkan-loader-devel SDL2_gfx-devel SDL2-devel libv4l-devel GraphicsMagick-devel ImageMagick-devel pipewire-jack-audio-connection-kit-devel 

# This enables powerline for all users by default if they are using the bash shell
# echo "" > file.xt overwrites the file.  We want to append this file, so we use echo "" >> file.xt
# We also echo in a command to autorun the sway DM for graphical capability.

echo 'if [ -f `which powerline-daemon` ]; then
  powerline-daemon -q
  POWERLINE_BASH_CONTINUATION=1
  POWERLINE_BASH_SELECT=1
  . /usr/share/powerline/bash/powerline.sh
fi;' >> /etc/skel/.bashrc

echo "if [ -z "${DISPLAY}" ] && [ "${XDG_VTNR}" -eq 1 ]; then
  exec sway
fi" >> /etc/skel/.bashrc

# This enables powerline in VIM.   Note powerline doesn't do anything but make the prompt look prettier.  I just like it, that's all.
echo 'python3 from powerline.vim import setup as powerline_setup
python3 powerline_setup()
python3 del powerline_setup
set laststatus=2 " Always display the statusline in all windows
set showtabline=2 " Always display the tabline, even if there is only one tab
set noshowmode " Hide the default mode text (e.g. -- INSERT -- below the statusline)
set t_Co=256' >> ~/.vimrc

# Enable the podman container service, we don't use this for now but I may start deploying things in containers if scaling becomes a problem.
sudo systemctl enable podman.service --now

# Create a wavelet user.  This user doesn't have sudo rights.  If you're signed in as that user, and need to get back to root you would need to execute the command
# su root and supply the root password.

# add Wavelet UID/user with specified password
# Yes, i'd rather generate a password as a random hash function but I'm too stupid to work out how to automate that and the SSH keypair generation for the controller right now.
# Contributions welcome :)
useradd -u 1337 wavelet -s /bin/bash -m 
chpasswd << 'END'
wavelet:WvltU$R60C
END

# Create wavelet homedir if not already created
mkdir -p /home/wavelet
cd /home/wavelet/

# Clone the UltraGrid source into /home/wavelet/UltraGrid
git clone https://github.com/CESNET/UltraGrid
cd UltraGrid

# run autogen to configure and make sure everything is supported as it should be.  If all the specified libraries above installed then we should be all set.
./autogen.sh
# compiles UltraGrid using as many CPU's as we can for speed
make -j$(nproc)
# takes the compiled binaries and installs then in /usr/bin/
make install
# You can test ultragrid by typing the following command
uv -d gl
# if that doesn't work, my instructions are wrong, a package changed, the UG source changed and we're all generally failures.

# Create autologin service for wavelet user
# This is so the machine starts up and immediately signs in as the unprivileged user wavelet.
# What's this doing?  Telling SystemD to tell 'get-tty' service to sign in as a the specified user.  The first unit file is required as a catch-all so that other users are still able # to sign in via cockpit, ssh or physical terminal and still get their own tty.   Whats a tty?    TeleTypeWriter.  The future is now.
echo "[Service]
ExecStart=-/sbin/agetty --noclear %I $TERM
Type=idle
Restart=always
RestartSec=0
UtmpIdentifier=%I
TTYPath=/dev/%I
TTYReset=yes
TTYVHangup=yes
TTYVTDisallocate=yes
KillMode=process
IgnoreSIGPIPE=no
SendSIGHUP=yes" > /lib/systemd/system/getty@.service

echo "[Service]
ExecStart=-/sbin/agetty -a wavelet --noclear %I $TERM
Type=idle
Restart=always
RestartSec=0
UtmpIdentifier=%I
TTYPath=/dev/%I
TTYReset=yes
TTYVHangup=yes
TTYVTDisallocate=yes
KillMode=process
IgnoreSIGPIPE=no
SendSIGHUP=yes" > /lib/systemd/system/getty@tty1.service

# enable linger so wavelet user can manage systemd without being logged in
loginctl enable-linger wavelet

# Enable tuned and set profile for our use case.  Tuned is just a lazy way of optimizing system performance without having to think too hard about it.  
# find and replace dynamic tuning setting to ensure this is enabled.
sed -i -e 's/dynamic_tuning = 0/dynamic_tuning = 1/g' /etc/tuned/tuned-main.conf
# Enable Tuned
systemctl enable tuned --now
#hopefully that doesn't spit out any errors

# disable systemd boot time services that are unnecessary, also tweak any other settings which increase reboot time.
# Because this system is going to be running fairly cut-down, we won't want to be loading normal services that are unnecessary
# These lines disable these services, saving boot time.
systemctl disable NetworkManager-wait-online.service --now
sed -i -e 's/GRUB_TIMEOUT=/GRUB_TIMEOUT=0/g' /etc/default/grub
dracut --regenerate-all --force


# Now we are onto the part where you'll be working as the wavelet user.   We should be done with anything that requires root or elevated privileges
# Change user to wavelet, you will be prompted for the password you set earlier.   I give-a-you three guesses.
su wavelet

# You Shall Not Pass!
# Challenge Accepted!

# Ok Good. 
# Create USER systemd service so that wavelet can start and stop the systemd services.   That's right, we can have system systemd services that need elevation to manage, but we can  
# also create user systemd services that are visible/managed only by specific users.

mkdir -p /home/wavelet/.config/systemd/user

# This defines a user system service for starting and stopping the decoder.

# start decoder service
echo "[Unit]
Description=Wavelet decoder viewer service
After=network.target

[Service]
Type=simple
#These environment variables commonly need to be set to tell the service which display to use for output.  On a PC its not all that finnicky..usually
#They are dependent on numerous considerations like the available GPU acceleration.  Since I lean towards Sway for the display, we will always be using Wayland as a Display Manager.
#Display=:0 is a command that defines a display for an older DM called Xorg.  
#Environment=SDL_VIDEODRIVER=wayland
#Environment=DISPLAY=:0
#Environment=WAYLAND_DISPLAY=wayland-1
ExecStop=/usr/bin/pkill -u %i -x uv
ExecStart=uv -d vulkan_sdl2:fs 
WorkingDirectory=/home/wavelet/

[Install]
WantedBy=multi-user.target" > /home/wavelet/.config/systemd/user/wavelet_start_decoder.service

#make sure the unit file is picked up
systemctl --user daemon-reload

# This should conclude setup on the decoder, as long as it's a PC running Fedora.  After this all that really needs to be done is connect it to the wavelet wireless network
# ssh-copy-id from the controller to the local wavelet user on the decoder and add its IP address into the wavelet_decoders file so that the controller will manage it properly.
# Done.

# I am working on scripting this and have already successfully written a script for Armbian/Debian/Ubuntu bring-ups.  It's early days yet so I'm sure a lot will and can break with 
# changes.
